{"./":{"url":"./","title":"Introduction","keywords":"","body":"data-hub 基本使用 安装 data-hub 是什么？ 核心概念 数据流动图 管道连接 开始 目录结构 API手册 数据板：Hub 数据池：Store 辅助工具 Vue：VuePlugin React：createRxHubComponent Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-11-12 01:02:24 "},"installation.html":{"url":"installation.html","title":"安装","keywords":"","body":"安装 安装依赖 data-hub 依赖 RxJS@5.x。 # install rxjs npm i rxjs@5.x npm 安装 # install data-hub npm i data-hub@latest -S 使用 es6 版 import {Sotre, Hub, logMiddleware, VuePlugin, createRxHubComponent, useRx} from 'data-hub'; 绑定Rx import {useRx, Hub} from 'data-hub'; import Rx from 'rxjs'; useRx(Rx); //let hub = new Hub 或者： import {useRx, Hub} from 'data-hub'; import {Observable, Subject} from 'rxjs/Rx'; useRx({Observable, Subject}); //let hub = new Hub es6 各部分单独使用 // store import Sotre from 'data-hub/src/store'; // hub import Hub from 'data-hub/src/hub'; // middleware import Sotre from 'data-hub/src/middleware/log'; // tool import VuePlugin from 'data-hub/src/tool/vue'; import createRxHubComponent from 'data-hub/src/tool/react'; 打包好的 commonjs 版（里面的 process.ENV.NODE_ENV 未编译） import { Sotre, Hub, logMiddleware, useRx, VuePlugin, createRxHubComponent, } from 'data-hub/dist/data-hub.common'; umd 开发版 dist/data-hub/data-hub.js umd 生产环境 dist/data-hub/data-hub.min.js Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-12-26 21:56:33 "},"intro.html":{"url":"intro.html","title":"data-hub 是什么？","keywords":"","body":"data-hub 是什么？ data-hub是一个数据层管理（数据的存储、流动、变换）工具， 依赖于 RxJS。 对于RxJS不太熟悉的，可以参考阅读我的这篇文章：轻松理解RxJS. data-hub 产生的目的 总结起来，不管任何应用，数据层的管理无外乎分为以下三个方面： 数据存储：可以将所有数据集中存储在一个地方，也可以按照模块等划分存在多个地方。 数据流动：一个操作引起数据变换，这中间的一系列过程可以看着一个数据流动。 数据变换：将存储的数据更新。 data-hub出现的目的，就是借助RxJS的先进的数据流管理，实现一个简单易用、一套数据适用各种场景（vue、react、原生js等……）的数据层管理工具。 data-hub 能做什么 无缝连接RxJS，能利用RxJS的所有强大的数据流管理和响应式编程功能。 内置一个数据存储的Store工具类，你可以在应用中，实例化一个或者多个Store实例来存储数据。 加入数据板(Hub)和数据管道(Pipe)的概念和工具，便捷地管理和监测每一次数据的流动、变换。 定义一套数据，即适用于各种场景，比如 React 项目、Vue 项目、和无框架项目等等。 虽然任何项目都能直接使用data-hub，还是提供了一些工具，方便开发者更快速地将data-hub融入Vue、React等项目中。 兼容性 支持node环境 浏览器: RxJS@5支持的各种环境，对应ie，支持ie9+。 Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-12-26 20:53:43 "},"core-concepts.html":{"url":"core-concepts.html","title":"核心概念","keywords":"","body":"核心概念 数据池：Store Store：每一个Store实例是一个独立的数据仓库，它内部的数据变换和获取都只能通过它暴露的接口进行。 单向数据流：store中的数据是变换是单向的，通过commit流入，通过get state流出。 并不是所有的数据都必须存进公共store，比如一些一次性数据，或者组件私有的数据就没必要存到公共store。 mutation: 数据变换，store 中的每一次数据变换都应该事先通过一个个mutation定义好，改动store的数据只能通过mutation操作。 commit: 提交一个mutation动作。 state: 获取store的即时数据。 定义一个 store import {Store, useRx} from 'data-hub'; import Rx, {Observable, Subject} from 'rxjs/Rx'; import user from './modules/user'; useRx(Rx); // or: useRx({Observable, Subject}); export default new Store({ // 初始状态 initialState: { loginUser: { username: 'season.chen' } }, // 子模块 modules: { user, // 用户子模块 }, // 数据变更 mutations: { setLoginUser(user, state) { state.loginUser = user; } } }); 数据流 一个操作引起数据变换，这中间的一系列过程可以看着一个数据流动。 比如： 添加用户操作：点击按钮产生一个数据流，这个流的初始内容是一个点击事件，经过变换转化为请求参数， 经过服务器之后，数据流的数据变化成新的用户, 再流入store存储起来。 获取sotre数据操作：产生一个数据流，流经Store，经过store.getState()变换后，流的数据变成了store的数据，再流入UI界面。 Observable：可观察的数据流 一个Observable流，可以理解为一个定义好的数据的流动通道，数据可能随时会在这个通道流动，你可以订阅它，这样数据到来时就会流到你那里。 分为两种，具体信息需要详细理解RxJS： 第一种：有观察者订阅，流才启动，并且只服务于一个观察者 第二种：流一直启动，可以服务于多个观察者。 Converter：数据流转换器 定义数据流的变换，接收一个数据，产生一个新的数据流。 每一个转换器是一个函数，传入一个数据对象payload, 传出一个可观察的数据流（Observable：RxJS数据流）或者可以通过Rx.Observable.from转换为数据流的对象。 详情参见：Rx.Observable.from. import Rx from 'rxjs/Rx'; // payload: userId export let userDel = (payload) => { let promise = new Promise((resolve, reject) => { // 处理一些删除用户的事情 setTimeout(() => resolve(payload), 1000); }); // 流出 return Rx.Observable.from(promise); }; // payload: userId export let userDel = (payload) => { let promise = new Promise((resolve, reject) => { // 处理一些删除用户的事情 setTimeout(() => resolve(payload), 1000); }); // 流出 return promise; }; Pipe： 数据管道 data-hub 将应用的每一次操作都新建一个临时数据流来管理，数据的流动过程中可能会产生很多数据变换。 一个流中的各个数据变换是通过一段段管道来定义的，数据流 经过这个管道就得到了转变, 产生新的数据流(注意：是变换数据流，不是简单的改变数据)。 管道可以插入在数据流的任何地方，它定义了： 流入格式 数据流如何变换（安装各种转换器） 流出格式 将 Converter 注册为 Pipe // 将用户操作的一段段水管装载到数据板上 hub.addPipes('server.user', userConverters); 通过数据板调用管道： // 这是一段管道 let getUserListPipe = hub.pipe('server.user.getList'); Observable.of({}) // 在整个数据流中间插入一段管道 .concatMap(getUserListPipe) // 订阅管道 .subscribe((users) => { console.log(users) }); Hub：数据板 一个管道Pipe是可以复用的，一个操作可能要用到很多管道，但是每个用的地方都需要引入的话，很麻烦。 数据板的功能，就是事先将这些管道安装在一个板上，引用的时候只有通过这个板就能很方便地调用管道。 它的功能有两个： 事先安装管道，便于随时取出管道 在管道上绑定前置和后置中间件 数据板定义了： 管道集合和调用名称 每一个管道流入前的变换（中间件） 每一个管道流出前的变换（中间件） import {Hub, logMiddleware, useRx} from 'data-hub'; import Rx from 'rxjs/Rx'; import * as userConverters from '../converters/user'; import * as storeConverters from '../converters/store'; useRx(Rx); // 初始化一个数据板实例，并给所有管道绑定中间件 const hub = new Hub({ beforeMiddlewares: [logMiddleware], afterMiddlewares: [logMiddleware], }); // 将用户相关的 Converter 集合快捷地添加为 数据板 的管道。 hub.addPipes('server.user', userConverters); // 将Store相关的 Converter 集合快捷地添加为 数据板 的管道。 hub.addPipes('store', storeConverters); export default hub; 中间件：Middleware 每一个中间件其实就是一个数据流转换器:Converter，主要用来监控或者统一变换数据，它统一安装在一个数据板的每一段管道（Pipe）的两端。 管道分为两种： beforeMiddlewares：安装在每一段管道的入口。 afterMiddlewares：安装在每一段管道的出口。 辅助工具 data-hub除了依赖RxJS外，直接就可以用在任何地方，但是为了在实际项目中使用方便，这里提供针对各种项目的一些辅助工具 VuePlugin：针对Vue项目 createRxHubComponent: 针对Reac项目。 Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-12-26 21:53:54 "},"overview.html":{"url":"overview.html","title":"数据流动图","keywords":"","body":"数据流动图 。 Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-12-26 20:53:43 "},"concat.html":{"url":"concat.html","title":"管道连接","keywords":"","body":"管道连接 data-hub 的一个操作产生一个临时数据流，数据流的中间可能会 连接很多管道. 由于管道是是通过转换器定义的，转换器接收一个数据，产生一个数据流。 所以，管道的连接一般使用如下的RxJS数据流的连接操作：operators: concatMap: 旧的数据流中的每一数据发射，映射为一个新的数据流，并且大平（新的等待旧的结束） exhaustMap：旧的数据流中的每一数据发射，映射为一个新的数据流（一个时刻只能有一个流，如果旧的流还未完成，新的将被忽略) switchMap：旧的数据流中的每一数据发射，映射为一个新的数据流（一个时刻只能有一个流，新的来临时drop旧的)。 Observable.fromEvent($btn, 'click') // 防抖动 .debounceTime(300) .pluck('target') .map(target => { let id = target.getAttribute('data-id'); NProgress.start(); return id; }) // 连接管道，新的服务器请求到来，如果旧的请求未返回，则忽略旧的 .switchMap(hub.pipe('server.user.userDel')) .map(id => { return { mutation: 'user.delete', payload: id } }) // 连接管道 .concatMap(hub.pipe('store.commit')) .subscribe(() => { console.log('success') NProgress.done(); }, (err) => { console.log(err); NProgress.done(); }); Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-12-26 20:53:43 "},"getting-started.html":{"url":"getting-started.html","title":"开始","keywords":"","body":"开始 定义数据存储：Store。 这是一个用户增删的简单应用的Store。 // data/stores/main.js import Rx, {Observable, Subject} from 'rxjs'; import {Store, useRx} from 'data-hub'; useRx(Rx); // or: useRx({Observable, Subject}); export default new Store({ debug: process.env.NODE_ENV !== 'production', initialState: { list: [] }, mutations: { add(user, state) { state.list.push(user); }, delete(id, state) { let list = state.list; let index = -1; list.forEach((item, idx) => { if (item.id == id) index = idx; }); list.splice(index, 1); }, update({id, newUser}, state) { let list = state.list; let index = -1; list.forEach((item, idx) => { if (item.id == id) index = idx; }); state.list[index] = newUser; } } }); 定义转换器 每一个转换器是一个函数，传入一个数据对象payload, 传出一个可观察的数据流（Observable：RxJS数据流）或者可以通过Rx.Observable.from转换为数据流的对象。 详情参见：Rx.Observable.from. // data/converters/user.js import axios from 'axios'; import Rx from 'rxjs'; // 删除用户：传入用户id，传出数据为 用户id的数据流 export let userDel = (userId) => { let promise = new Promise((resolve, reject) => { // 处理一些删除用户的事情 setTimeout(() => resolve(userId), 1000); }); return promise; }; // 添加用户：传入用户信息`user`，传出服务器返回的数据对象 export let userAdd = (user) => { let promsie = axios({ url: 'http://www.baidu.com', method: 'post', data: data }).then(response => { return response.data }); return promise; }; // data/converters/store.js import {BehaviorSubject, Observable} from 'rxjs'; import mainStore from '../stores/main'; // store的状态，流入空数据，流出store的状态 export let getState = () => { let state = mainStore.state; let subject = new BehaviorSubject(state); mainStore.subscribe(subject); return subject; }; // 提交更改store,流入store变换信息，流出变换数据 export let commit = ({mutation, payload}) => { mainStore.commit(mutation, payload); return Observable.of(payload); }; 定义一个数据板（Hub） import {Hub, logMiddleware, useRx} from 'data-hub'; import Rx from 'rxjs/Rx'; import mainStore from '../stores/main'; import * as userConverters from '../converters/user'; import * as storeConverters from '../converters/store'; useRx(Rx); // 初始化一个数据板实例 const hub = new Hub({ beforeMiddlewares: [logMiddleware], afterMiddlewares: [logMiddleware], }); // 将用户操作的一段段水管装载到数据板上 hub.addPipes('server.user', userConverters); // 将Store操作的一段段水管装载到数据板上 hub.addPipes('store', storeConverters); export default hub; 使用数据板和store 模板文件： data-hub with simple javascript user: username 添加 id 用户名 操作 js 文件： import hub from '../data/hubs/main'; import {Observable} from 'rxjs/Rx'; import NProgress from 'nprogress'; import 'nprogress/nprogress.css'; import \"../style/style.less\"; let $app = document.getElementById('app'); let $filter = document.getElementById('filter'); let $btn = document.getElementById('search'); let $table = document.getElementById('table'); let userList = []; // rerender table function updateTable() { let filter = $filter.value.trim(); let $rows = userList.filter(user => { return user.name.indexOf(filter) != -1; }) .map((user, i) => { return ` ${user.id} ${user.name} 删除 `; }); // bind delete user $table.querySelector('tbody').innerHTML = $rows.join(''); $table.querySelectorAll('tr > td > button').forEach(($btn, index) => { // delete Observable.fromEvent($btn, 'click') .pluck('target') .map(target => { let id = target.getAttribute('data-id'); NProgress.start(); return id; }) .switchMap(hub.pipe('server.user.userDel')) .map(id => { return { mutation: 'user.delete', payload: id } }) .concatMap(hub.pipe('store.commit')) .subscribe(() => { console.log('success') NProgress.done(); }, (err) => { console.log(err); NProgress.done(); }); }); } // watch state change Observable.of({}) .concatMap(hub.pipe('store.getState')) .subscribe((state) => { userList = state.user.list; updateTable(); }); // filter input Observable.fromEvent($filter, 'input') .debounceTime(500) .subscribe(() => { updateTable(); }); // add new user let addUserSubscription; $btn.addEventListener('click', () => { // unsubscibe if (addUserSubscription) addUserSubscription.unsubscribe(); let user = { id: Date.now(), name: 'user-' + Math.round(Math.random() * 1000000), } NProgress.start(); addUserSubscription = Observable.of(user) .switchMap(hub.pipe('server.user.userAdd')) .map((user) => { return { mutation: 'user.add', payload: user } }) .concatMap(hub.pipe('store.commit')) .subscribe(() => { console.log('success') NProgress.done(); }, (err) => { console.log(err); NProgress.done(); }); }); Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-12-26 21:55:35 "},"structure.html":{"url":"structure.html","title":"目录结构","keywords":"","body":"目录结构 | |---- `style` |---- `entry` |---- `lib` |---- `data`: 数据管理 | |---- `converters` | |---- `server` | | |---- `user.js` | | | |---- `store.js` | |---- `hubs` | |---- `main.js` | |---- `stores` | |---- `main.js` |---- `modules` |- `user.js` Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-11-12 01:02:24 "},"api/hub.html":{"url":"api/hub.html","title":"数据板：Hub","keywords":"","body":"数据板：Hub let hub = new Hub(options): 创建实Hub例. import {Hub} from 'data-hub'; const hub = new Hub({ // 管道进入前的中间件 beforeMiddlewares: [logMiddleware], // 管道流程后经过的中间件 afterMiddlewares: [logMiddleware], }); hub.Rx: useRx(Rx)中的Rx. hub.addPipe(name, converter): 添加一个管道。 name: 管道名称 converter: Converter hub.addPipe('user.addUser', (payload) => { let promise = new Promise((resolve, reject) => { setTimeout(() => resolve(payload), 1000); }); return Rx.Observable.from(promise); }); // or import {addUser} from '../converters/user'; hub.addPipe('user.addUser', addUser); hub.addPipes(context, converters): 添加一批管道。 context: 管道集合名 converters: Conterver集合 // add pipes: user.addUser, user.deleteUser ... import userConverters from '../converters/user'; hub.addPipe('user', userConverters); hub.addMiddleware(type, middleware): 添加中间件。 type: 中间件位置， before|after。 middleware: 中间件，特殊的Converter。 import {logMiddleware} from 'data-hub'; hub.addMiddleware('before', logMiddleware); Middleware: 中间件。 一个中间件其实就是一个Converter, 只是放置的位置不一样而已。中间件分为两种类型，beforeMiddleware和afterMiddleware。 中间件每个位置可以安装多个，主要用来做调试、打印日志、数据监控、统一变换等。 beforeMiddleware: 在数据流入管道的时候调用。 afterMiddleware: 在数据流出管道的时候调用。 Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-12-26 21:57:48 "},"api/store.html":{"url":"api/store.html","title":"数据池：Store","keywords":"","body":"数据池：Store new Store(options): 实例化一个Store。 import {Store} from 'data-hub'; let store = new Store({ // options: // 开启调试模式后，每一次commit都会打印出来 debug: process.env.NODE_ENV !== 'production', // store 的名字，主要是方便调试 name: 'storeName', // 初始化状态 initialState: { loginUser: { username: 'season.chen' } }, // 模块，key: value的形式 // 每一个模块是一个Store实例 modules: { user, }, // 数据变更操作配置，定义这个store的所有数据变更 mutations: { // payload: 传入数据 // state: store的数据对象 setLoginUser(payload, state) { state.loginUser = payload; }, } }) store.commit(mutation, payload): 提交一个变更。 mutation: 变更名字，对应于sotre 的mutations。 如果mutation包含.分隔符, 则表示此次变更是提交给子模块的，而不是本store的变更。 分隔符.前面的表示子模块的名字，后面表示提交给子模块的变更的名字。 如store.commit('setLoginUser', {})表示应用到本 store 的变更: setLoginUser。 而store.commit('user.add', {})表示应用模块: user的变更: add。 payload: 变更的数据。 store.subscribe(observer): 订阅变更。 如果订阅，store的每次commit提交都会通知观察者。 store.subscribe((state) => { // the store's new state is `state` console.log(state.loginUser); }); store.getState(): 获取store的状态。 store.copy(nodePath): 克隆state的一个节点。 let userList = store.copy('user.list'); observable.subscribe(store): sotre 也可以作为观察者来进行变更数据, 数据流传入的数据格式必须是{payload, mutation}。 let newUser = { //... } Rx.Observable.of({ // mutation mutation: 'setLoginUser', // payload payload: newUser, }).subscribe(store) // equal to: Rx.Observable.of({ // mutation mutation: 'setLoginUser', // payload payload: newUser, }).subscribe(({mutation, payload}) => { store.commit(mutation, payload); }); Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-12-26 20:53:43 "},"tool/vue.html":{"url":"tool/vue.html","title":"Vue：VuePlugin","keywords":"","body":"VuePlugin 绑定插件 import Vue from 'vue'; import {VuePlugin} from 'data-hub'; Vue.use(VuePlugin, { storeOptionKey: 'store', storeKey: '$store', hubOptionKey: 'hub', hubKey: '$hub', stateKey: '$state', subscriptionsKey: '$subs' }); 在根组件绑定hub 和 store 在根组件上绑定后，每个组件中会有异性几个属性, 这些属性的名字都可以在使用插件的时候自定义。 vm.$store: Store实例。 vm.$hub: 数据板实例 vm.$state: 响应式的state，关联到store.state. vm.$subs: 用来绑定订阅，组件内新建订阅的时候最好绑定在这上面，组件离开时会取消这些订阅（例：vm.$subs.addUser = Observable.of(1).subscribe(item => {})）。 vm.$unsubscribe(key): 取消一个绑定在vm.$subs上的订阅，不传key则取消所有订阅。 import hub from '../data/hubs/main'; import store from '../data/stores/main'; new Vue({ store, hub, // computed: { user() { return this.$sotre.state.user; } } }) 使用 获取数据: 一般直接从vm.$store.state获取，或者通过计算属性获取。 export default { computed: { user() { return this.$store.state.user; } }, mounted() { console.log(this.$store.state.user) } }; 数据变换: 每一次数据变换开始一个管道。 export default { methods: { addItem() { // 放弃上次订阅，如果有 this.$unsubscribe('addItem'); // 开始一个数据流 NProgress.start(); this.$subs.addItem = Rx.Observable // 初始化数据 .of({ id: Date.now(), name: 'user-' + Math.round(Math.random() * 1000000), }) // 服务器添加 .switchMap(this.$hub.pipe('server.user.userAdd')) // 构建store转换数据 .map((user) => { return { mutation: 'user.add', payload: user } }) // 提交store变换 .concatMap(this.$hub.pipe('store.commit')) // 订阅 .subscribe(() => { console.log('success') NProgress.done(); }, (err) => { console.log(err); NProgress.done(); }); } } }; 不能直接更改state，如果要把store的一些值初始化为data，可以用store.copy。 data () { const store = this.$store; return { user: store.copy(store) } } Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-12-26 20:53:43 "},"tool/react.html":{"url":"tool/react.html","title":"React：createRxHubComponent","keywords":"","body":"createRxHubComponent 构建一个基类, 绑定hub、store，其他组件继承这个基类。 然后继承这个基类的会有如下属性， 这些属性的名字都可以在使用插件的时候自定义，组件如果没有componentWillUnMount钩子，默认会在componentWillUnMount钩子上调用this.$unsubscribe()。 如果组件自定义了 componentWillUnMount ，最好在 componentWillUnMount 中调用this.$unsubscribe()。 this.$store: Store实例。 this.$hub: 数据板实例 this.$subs: 用来绑定订阅，组件内新建订阅的时候最好绑定在这上面，组件离开时会取消这些订阅（例：this.$subs.addUser = Observable.of(1).subscribe(item => {})）。 this.$unsubscribe(key): 取消一个绑定在this.$subs上的订阅，不传key则取消所有订阅。 import React from 'react'; import {createRxHubComponent} from 'data-hub'; import hub from '../data/hubs/main'; import store from '../data/stores/main'; const Base = createRxHubComponent({ hub, store, storeKey = '$store', hubKey = '$hub', subscriptionsKey = '$subs' }, React); export default Base; 组件里使用store状态 import React from 'react'; import BaseComponent from './Base'; class App extends BaseComponent { constructor(props) { super(props, true); // init state this.state = { state: this.$store.state.user.list, }; // 订阅store变更，改变state this.$subs.store = this.$store.subscribe(state => { this.setState({ state: state }); }); } } export default App; 数据变换: 每一次数据变换开始一个管道。 class APP extends BaseComponent { // ... addUser() { // 放弃上次订阅，如果有 this.$unsubscribe('addItem'); // 开始一个数据流 NProgress.start(); this.$subs.addItem = Rx.Observable // 初始化数据 .of({ id: Date.now(), name: 'user-' + Math.round(Math.random() * 1000000), }) // 服务器添加 .switchMap(this.$hub.pipe('server.user.userAdd')) // 构建store转换数据 .map((user) => { return { mutation: 'user.add', payload: user } }) // 提交store变换 .concatMap(this.$hub.pipe('store.commit')) // 订阅 .subscribe(() => { console.log('success') NProgress.done(); }, (err) => { console.log(err); NProgress.done(); }); } } Copyright © season.chen all right reserved，powered by Gitbook该文件修订时间： 2017-12-26 22:00:23 "}}